

-----------------------------------------------------------------------------

The version of Lua used is 5.2.

-----------------------------------------------------------------------------

# Telnet into Lua process

> telnet ev3dev.local 9100
    or
> nc ev3dev.local 9100

_^D to exit_

-----------------------------------------------------------------------------

# Script Interface to the Process Wrapper

Two libraries are added by default:
* proc
* log


## Script Callback Handlers

These are not delivered via the normal event system, but are global Lua functions
called directly by the C++ wrapping code.

* `setup()`
* `event_handler()`
* `mainloop()`  should this just be loop()?

## Script Events

These events are generated by the Lua Process Wrapper and delivered to that processes' script
via the function `event_handler`.  

* `timer`
* `timeout`


## Process Module

`proc`

### Functions

* set_cycle_time
* get_cycle_time
* set_timer()
* get_timer()
* set_timeout()
* clear_timeout()
* exit()


#### set_cycle_time()

`set_cycle_time( seconds )`

Sets the mainloop frequency in seconds. Seconds is a floating-point value.
This is the frequency with which the Luna `mainloop()` function will be called.
If zero, the `mainloop()` Lua function will be called as frequently as the system
can manage (no delays).


#### get_cycle_time()

`get_cycle_time()`

Returns the interval (in seconds) that the mainloop will be called at.
If zero, the `mainloop()` Lua function will be called as frequently as the system
can manage (no delays).


#### set_timer()

`set_timer( seconds )`

Sets a repeating timer event's time in seconds. Seconds is a floating-point value.
To halt the timer events, use a time of 0.  
This will generate a local event named `timer` at the interval set.


#### get_timer()

`get_timer()`

Returns the current value (in seconds) of the repeating timer.

#### set_timeout()

`set_timeout( seconds )`

Sets a one-shot timer in seconds. Seconds is a floating-point value.  
When the interval specified elapses, a local event named `timeout` will be generated.

The timeout timer is intended to support, well, a timeout. This let's you respond to the case
where something that you expected to happen before the timeout elapsed did not happen.  
In normal use, when the desired event occurs you call `clear_timeout()` and the `timeout` event never occurs.


#### clear_timeout()

`clear_timeout()`

Clears the timeout timer, preventing the `timeout` even from being generated.


#### sleep()

`sleep()`

Does a blocking wait for the given time in seconds.


#### exit()

`exit( [exit-code] )

Exits the application.

* exit-code - An optional return code that will be used when the program exits.




## Log Module

`log`

### Functions

* info()
* warn()
* error()
* print()


#### info()

`info( string )`

Sends the given string to the log system.



